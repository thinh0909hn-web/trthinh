<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Grand Luxury Tree ‚Äî Slots Edition</title>

  <style>
    :root{
      --bg:#050d1a;
      --panel: rgba(10,10,10,0.62);
      --line: rgba(212,175,55,0.22);
      --gold: rgba(212,175,55,0.95);
      --gold2: rgba(252,238,167,0.95);
      --txt: rgba(252,238,167,0.92);
      --muted: rgba(212,175,55,0.55);
      --shadow: rgba(0,0,0,0.55);
    }
    *{ box-sizing:border-box; }

    body{
      margin:0;
      overflow:hidden;
      background: radial-gradient(circle at center, #0f2027 0%, #203a43 50%, #2c5364 100%);
      background-color: var(--bg);
      font-family: 'Times New Roman', serif;
      color: var(--txt);
      touch-action: manipulation;
    }

    #canvas-container{ position:absolute; inset:0; z-index:1; }

    /* Loader */
    #loader{
      position:absolute; inset:0;
      background: var(--bg);
      z-index:200;
      display:flex; flex-direction:column;
      align-items:center; justify-content:center;
      transition: opacity .8s ease-out;
    }
    .spinner{
      width:44px; height:44px;
      border:1px solid rgba(212,175,55,0.2);
      border-top:1px solid rgba(212,175,55,1);
      border-radius:50%;
      animation: spin 1s linear infinite;
    }
    .loader-text{
      margin-top:18px;
      color: var(--gold);
      font-size:12px;
      letter-spacing:4px;
      text-transform:uppercase;
      opacity:.9;
    }
    @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}

    /* Top UI */
    #ui-layer{
      position:absolute; inset:0;
      z-index:10;
      pointer-events:none;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding-top: calc(env(safe-area-inset-top, 0px) + 14px);
      transition: opacity .25s ease;
    }
    .ui-hidden{ opacity:0 !important; pointer-events:none !important; }

    #title{
      margin:0;
      padding: 0 108px 0 14px;
      max-width:min(92vw, 880px);
      line-height:1.05;
      font-weight:400;
      letter-spacing:3px;
      text-shadow: 0 0 42px rgba(252,238,167,0.45);
      background: linear-gradient(to bottom, #fff, #eebb66);
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      font-family: 'Cinzel', 'Times New Roman', serif;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      user-select:none;
      opacity:.96;
    }
    @media (max-width:600px){
      #title{ font-size:26px; letter-spacing:2px; padding-right:104px; }
    }
    @media (min-width:601px){
      #title{ font-size:54px; }
    }

    #top-controls{
      position:absolute;
      top: calc(env(safe-area-inset-top, 0px) + 10px);
      right: 12px;
      z-index:30;
      pointer-events:auto;
      display:flex;
      gap:10px;
      align-items:center;
    }

    .icon-btn{
      width:44px; height:44px;
      border-radius:14px;
      border:1px solid rgba(212,175,55,0.45);
      background: rgba(20,20,20,0.55);
      backdrop-filter: blur(10px);
      box-shadow: 0 12px 34px rgba(0,0,0,0.35);
      cursor:pointer;
      -webkit-tap-highlight-color:transparent;
      display:grid; place-items:center;
      transition: .18s ease;
      color: var(--gold);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      font-weight:700;
      user-select:none;
    }
    .icon-btn:active{ transform: translateY(1px) scale(0.98); }

    .icon{ width:18px; height:18px; position:relative; }
    .icon.ham::before, .icon.ham::after, .icon.ham span{
      content:"";
      position:absolute; left:0; right:0;
      height:2px;
      background: rgba(212,175,55,0.92);
      border-radius:2px;
    }
    .icon.ham::before{ top:2px; }
    .icon.ham span{ top:8px; }
    .icon.ham::after{ top:14px; }

    /* Menu */
    #menu-backdrop{
      position:absolute; inset:0;
      z-index:39;
      opacity:0;
      pointer-events:none;
      background: rgba(0,0,0,0.18);
      transition: opacity .18s ease;
    }
    #menu-backdrop.open{ opacity:1; pointer-events:auto; }

    #menu-panel{
      position:absolute;
      top: calc(env(safe-area-inset-top, 0px) + 62px);
      right: 12px;
      z-index:40;
      width: min(340px, 92vw);
      border-radius: 18px;
      background: rgba(10,10,10,0.62);
      border: 1px solid rgba(212,175,55,0.22);
      backdrop-filter: blur(14px);
      box-shadow: 0 22px 70px rgba(0,0,0,0.55);
      padding: 10px;
      transform-origin: top right;
      transform: translateY(-6px) scale(0.97);
      opacity: 0;
      pointer-events: none;
      transition: .2s ease;
    }
    #menu-panel.open{
      opacity:1;
      transform: translateY(0) scale(1);
      pointer-events:auto;
    }
    .menu-title{
      color: rgba(252,238,167,0.95);
      font-family: 'Cinzel', serif;
      letter-spacing:2px;
      font-size:12px;
      text-transform:uppercase;
      padding: 6px 10px 10px;
      user-select:none;
    }

    .menu-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      padding: 0 2px 2px;
    }
    .btn{
      border: 1px solid rgba(212,175,55,0.18);
      background: rgba(255,255,255,0.04);
      border-radius: 16px;
      padding: 12px 12px;
      color: rgba(212,175,55,0.95);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
      transition: .18s ease;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      font-size:12px;
      letter-spacing:1px;
      text-transform:uppercase;
    }
    .btn:hover{
      background: rgba(212,175,55,0.13);
      border-color: rgba(212,175,55,0.42);
    }
    .btn:active{ transform: translateY(1px); }
    .badge{
      font-size:10px;
      letter-spacing:1px;
      opacity:0.75;
      padding: 4px 8px;
      border-radius:999px;
      border: 1px solid rgba(212,175,55,0.22);
      background: rgba(0,0,0,0.12);
      flex: 0 0 auto;
      text-transform:none;
    }
    .hint{
      padding: 8px 10px 6px;
      color: rgba(212,175,55,0.60);
      font-size:10px;
      line-height:1.35;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }

    /* Drawer Backdrop */
    #drawer-backdrop{
      position:absolute; inset:0;
      z-index:54;
      opacity:0;
      pointer-events:none;
      background: rgba(0,0,0,0.28);
      transition: opacity .18s ease;
    }
    #drawer-backdrop.open{ opacity:1; pointer-events:auto; }

    /* Drawer (iOS-like) */
    #drawer{
      position:absolute;
      left: 12px;
      right: 12px;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 12px);
      z-index:55;
      pointer-events:auto;
      border-radius: 22px;
      border: 1px solid rgba(212,175,55,0.22);
      background: rgba(10,10,10,0.58);
      backdrop-filter: blur(14px);
      box-shadow: 0 22px 80px rgba(0,0,0,0.55);
      overflow:hidden;

      max-height: min(72vh, 720px);

      transform: translateY(18px);
      opacity:0;
      pointer-events:none;
      transition: .22s ease;
      display:flex;
      flex-direction:column;
    }
    #drawer.open{
      transform: translateY(0);
      opacity:1;
      pointer-events:auto;
    }

    .drawer-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px 10px;
      border-bottom: 1px solid rgba(212,175,55,0.14);
      gap: 10px;
      flex: 0 0 auto;
    }
    .handle{
      position:absolute;
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
      width: 46px;
      height: 5px;
      border-radius: 999px;
      background: rgba(252,238,167,0.25);
      border: 1px solid rgba(212,175,55,0.12);
      pointer-events:none;
    }

    .drawer-title{
      font-family: 'Cinzel', serif;
      letter-spacing:2px;
      text-transform:uppercase;
      font-size:12px;
      color: rgba(252,238,167,0.95);
      user-select:none;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 40vw;
    }
    .drawer-actions{
      display:flex; gap:8px; align-items:center;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    .chip{
      border: 1px solid rgba(212,175,55,0.20);
      background: rgba(255,255,255,0.05);
      color: rgba(212,175,55,0.95);
      padding: 9px 10px;
      border-radius: 999px;
      font-size:11px;
      letter-spacing:1px;
      text-transform:uppercase;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
      display:flex;
      align-items:center;
      gap:8px;
      white-space:nowrap;
    }
    .chip:active{ transform: translateY(1px); }
    .chip strong{
      font-size:10px;
      opacity:.8;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(212,175,55,0.16);
      background: rgba(0,0,0,0.14);
      letter-spacing:1px;
    }

    .drawer-body{
      flex: 1 1 auto;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      padding: 12px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .section{
      border: 1px solid rgba(212,175,55,0.14);
      background: rgba(255,255,255,0.03);
      border-radius: 18px;
      padding: 10px;
    }
    .section-title{
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      font-size:11px;
      letter-spacing:1px;
      text-transform:uppercase;
      color: rgba(212,175,55,0.9);
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom: 10px;
      user-select:none;
      gap: 10px;
    }
    .small{
      color: rgba(212,175,55,0.65);
      font-size:10px;
      letter-spacing:0.8px;
      text-transform:none;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 46vw;
    }

    /* Slots grid */
    #slots{
      display:grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 8px;
    }
    @media (max-width:560px){
      #slots{ grid-template-columns: repeat(5, 1fr); }
    }
    .slot{
      aspect-ratio: 1/1;
      border-radius: 14px;
      border: 1px solid rgba(212,175,55,0.18);
      background: rgba(0,0,0,0.18);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
      overflow:hidden;
      cursor:pointer;
      position:relative;
      -webkit-tap-highlight-color:transparent;
    }
    .slot.selected{
      border-color: rgba(212,175,55,0.70);
      box-shadow: 0 0 0 2px rgba(212,175,55,0.20), inset 0 0 0 1px rgba(255,255,255,0.03);
    }
    .slot img{
      width:100%; height:100%;
      object-fit: cover;
      display:block;
      filter: saturate(1.05) contrast(1.02);
    }
    .slot .num{
      position:absolute;
      top:6px; left:6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:10px;
      color: rgba(252,238,167,0.9);
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(212,175,55,0.18);
      padding: 2px 6px;
      border-radius: 999px;
    }
    .slot .state{
      position:absolute;
      right:6px; bottom:6px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      font-size:10px;
      letter-spacing:1px;
      text-transform:uppercase;
      color: rgba(212,175,55,0.88);
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(212,175,55,0.18);
      padding: 2px 6px;
      border-radius: 999px;
    }

    /* Gallery */
    #gallery{
      display:grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 8px;
    }
    @media (max-width:560px){
      #gallery{ grid-template-columns: repeat(5, 1fr); }
    }
    .thumb{
      aspect-ratio: 1/1;
      border-radius: 14px;
      overflow:hidden;
      cursor:pointer;
      border: 1px solid rgba(212,175,55,0.14);
      background: rgba(0,0,0,0.18);
      -webkit-tap-highlight-color:transparent;
      position:relative;
    }
    .thumb img{
      width:100%; height:100%;
      object-fit: cover;
      display:block;
      filter: saturate(1.05) contrast(1.02);
      transform: scale(1.02);
    }
    .thumb:hover{ border-color: rgba(212,175,55,0.45); }

    #toast{
      position:absolute;
      left: 12px;
      top: calc(env(safe-area-inset-top, 0px) + 70px);
      z-index:80;
      pointer-events:none;
      opacity:0;
      transform: translateY(-6px);
      transition: .22s ease;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(212,175,55,0.22);
      background: rgba(10,10,10,0.58);
      backdrop-filter: blur(12px);
      box-shadow: 0 18px 60px rgba(0,0,0,0.55);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      font-size: 11px;
      letter-spacing: 1px;
      text-transform: uppercase;
      color: rgba(252,238,167,0.95);
      max-width: 88vw;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #toast.show{ opacity:1; transform: translateY(0); }

    input[type="file"]{ display:none; }
  </style>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <!-- üéµ Autoplay BGM (no button) -->
  <audio id="bgm" src="https://files.catbox.moe/7ibpf5.mp3" preload="auto" loop playsinline></audio>

  <div id="loader">
    <div class="spinner"></div>
    <div class="loader-text">Loading Scene</div>
  </div>

  <div id="canvas-container"></div>

  <div id="ui-layer">
    <h1 id="title">Merry Christmas</h1>
    <div id="top-controls">
      <button class="icon-btn" id="btn-drawer" title="Photos">üñº</button>
      <button class="icon-btn" id="btn-menu" aria-label="Menu">
        <div class="icon ham"><span></span></div>
      </button>
    </div>
  </div>

  <div id="toast"></div>

  <!-- Menu -->
  <div id="menu-backdrop"></div>
  <div id="menu-panel">
    <div class="menu-title">Controls</div>
    <div class="menu-grid">
      <button class="btn" id="btn-snow" type="button"><span>Snow</span><span class="badge" id="snow-state">ON</span></button>
      <button class="btn" id="btn-reset" type="button"><span>Reset View</span><span class="badge">R</span></button>
      <button class="btn" id="btn-ui-toggle" type="button"><span>Hide UI</span><span class="badge">H</span></button>
      <button class="btn" id="btn-shuffle" type="button"><span>Shuffle Photos</span><span class="badge">‚áÑ</span></button>
    </div>
    <div class="hint">
      Tip: B·∫°n c√≥ th·ªÉ <b>b·∫•m th·∫≥ng v√†o khung ·∫£nh tr√™n c√¢y</b> ƒë·ªÉ ch·ªçn slot, r·ªìi ch·ªçn ·∫£nh ƒë·ªÉ thay.
    </div>
  </div>

  <!-- Drawer backdrop -->
  <div id="drawer-backdrop"></div>

  <!-- Drawer -->
  <div id="drawer">
    <div class="handle"></div>
    <div class="drawer-head" id="drawer-head">
      <div class="drawer-title">Photos ‚Äî Slot Replace</div>
      <div class="drawer-actions">
        <label class="chip" title="Select files">
          Upload <strong id="count-badge">0</strong>
          <input type="file" id="file-input" multiple accept="image/*" />
        </label>
        <button class="chip" id="btn-clear-slot" title="Clear selected slot">Clear<strong>DEL</strong></button>
        <button class="chip" id="btn-close-drawer" title="Close">Close<strong>‚úï</strong></button>
      </div>
    </div>

    <div class="drawer-body" id="drawer-body">
      <div class="section">
        <div class="section-title">
          <span>Slots (khung tr√™n c√¢y)</span>
          <span class="small" id="slot-hint">Ch·ªçn 1 slot ƒë·ªÉ thay ·∫£nh</span>
        </div>
        <div id="slots"></div>
      </div>

      <div class="section">
        <div class="section-title">
          <span>Gallery (·∫£nh ƒë√£ upload)</span>
          <span class="small">Tap ·∫£nh ƒë·ªÉ g√°n v√†o slot ƒëang ch·ªçn</span>
        </div>
        <div id="gallery"></div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

    const CONFIG = {
      colors: {
        bg: 0x050d1a,
        fog: 0x050d1a,
        champagneGold: 0xffd966,
        deepGreen: 0x03180a,
        accentRed: 0x990000,
      },
      particles: {
        count: 1450,
        dustCount: 1800,
        snowCount: 950,
        treeHeight: 24,
        treeRadius: 8
      },
      camera: { z: 50 },
      slots: {
        count: 18,
        baseScale: 1.2,
        rOffset: 4.9,
        loops: 3.2
      },
      preloadThumbs: [
        'https://images.unsplash.com/photo-1543589077-47d81606c1bf?q=80&w=900',
        'https://images.unsplash.com/photo-1576919228236-a097c32a5cd4?q=80&w=900',
        'https://images.unsplash.com/photo-1512389142860-9c449e58a543?q=80&w=900',
        'https://images.unsplash.com/photo-1482638588057-dce9509db949?q=80&w=900'
      ]
    };

    const STATE = {
      mode: 'TREE',
      rotation: { x: 0, y: 0 },
      flags: { snow: true, uiHidden: false },
      selectedSlot: -1,
      toastTimer: null,
      drawerDragging: false,
      drawerStartY: 0,
      drawerDragDY: 0
    };

    // DOM
    const menuBtn = document.getElementById('btn-menu');
    const drawerBtn = document.getElementById('btn-drawer');
    const menuPanel = document.getElementById('menu-panel');
    const menuBackdrop = document.getElementById('menu-backdrop');
    const snowState = document.getElementById('snow-state');

    const drawer = document.getElementById('drawer');
    const drawerBackdrop = document.getElementById('drawer-backdrop');
    const btnCloseDrawer = document.getElementById('btn-close-drawer');
    const fileInput = document.getElementById('file-input');

    const slotsEl = document.getElementById('slots');
    const galleryEl = document.getElementById('gallery');
    const slotHint = document.getElementById('slot-hint');
    const countBadge = document.getElementById('count-badge');
    const toast = document.getElementById('toast');

    const drawerHead = document.getElementById('drawer-head');
    const drawerBody = document.getElementById('drawer-body');

    // üéµ BGM
    const bgm = document.getElementById('bgm');

    // THREE
    let scene, camera, renderer, composer;
    let mainGroup;
    let clock = new THREE.Clock();
    let particleSystem = [];
    let caneTexture;
    let snowSystem;
    let lightsMesh = null;
    let garlandMesh = null;

    // Raycaster for click slot on tree
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    // Slots system (3D)
    const slotMeshes = [];      // each: { group, frame, photo, texture, assignedId, isEmpty, uiThumbEl }
    const slotTargets = [];     // Vector3 posTree per slot

    // Gallery
    const gallery = [];         // { id, dataUrl, texture, thumbUrl }
    let idCounter = 1;

    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add('show');
      clearTimeout(STATE.toastTimer);
      STATE.toastTimer = setTimeout(()=>toast.classList.remove('show'), 1400);
    }

    async function safeAutoPlayBgm(){
      try{
        bgm.volume = 0.9;   // "to t√≠"
        await bgm.play();
      }catch(e){
        // autoplay b·ªã ch·∫∑n -> play sau l·∫ßn ch·∫°m ƒë·∫ßu ti√™n (kh√¥ng c·∫ßn n√∫t)
        const resume = async () => {
          try{
            bgm.volume = 0.9;
            await bgm.play();
          }catch(_){}
          window.removeEventListener('pointerdown', resume, {capture:true});
          window.removeEventListener('touchstart', resume, {capture:true});
        };
        window.addEventListener('pointerdown', resume, { once:true, capture:true });
        window.addEventListener('touchstart', resume, { once:true, capture:true });
      }
    }

    async function init() {
      initThree();
      setupEnvironment();
      setupLights();
      createTextures();
      createParticles();
      createDust();
      createFairyLights();
      createGarland();
      createSnow();
      createSlots3D();     // slot frames
      preloadGallery();    // preload images
      setupPostProcessing();
      setupEvents();
      buildSlotsUI();
      renderGalleryUI();

      const loader = document.getElementById('loader');
      loader.style.opacity = 0;
      setTimeout(() => loader.remove(), 800);

      // üéµ try autoplay
      safeAutoPlayBgm();

      animate();
    }

    function initThree() {
      const container = document.getElementById('canvas-container');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(CONFIG.colors.bg);
      scene.fog = new THREE.FogExp2(CONFIG.colors.fog, 0.015);

      camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, CONFIG.camera.z);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.toneMapping = THREE.ReinhardToneMapping;
      renderer.toneMappingExposure = 2.2;
      container.appendChild(renderer.domElement);

      mainGroup = new THREE.Group();
      scene.add(mainGroup);
    }

    function setupEnvironment() {
      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
    }

    function setupLights() {
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));

      const innerLight = new THREE.PointLight(0xffaa00, 2, 22);
      innerLight.position.set(0, 5, 0);
      mainGroup.add(innerLight);

      const spotGold = new THREE.SpotLight(0xffcc66, 1200);
      spotGold.position.set(30, 40, 40);
      spotGold.angle = 0.5;
      spotGold.penumbra = 0.5;
      scene.add(spotGold);

      const spotBlue = new THREE.SpotLight(0x6688ff, 800);
      spotBlue.position.set(-30, 20, -30);
      scene.add(spotBlue);

      const fill = new THREE.DirectionalLight(0xffeebb, 0.9);
      fill.position.set(0, 0, 50);
      scene.add(fill);
    }

    function setupPostProcessing() {
      const renderScene = new RenderPass(scene, camera);
      const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
      bloomPass.threshold = 0.62;
      bloomPass.strength = 0.65;
      bloomPass.radius = 0.55;

      composer = new EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);
    }

    function createTextures() {
      const canvas = document.createElement('canvas');
      canvas.width = 128; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, 128, 128);
      ctx.fillStyle = '#880000';
      ctx.beginPath();
      for (let i = -128; i < 256; i += 32) {
        ctx.moveTo(i, 0); ctx.lineTo(i + 32, 128); ctx.lineTo(i + 16, 128); ctx.lineTo(i - 16, 0);
      }
      ctx.fill();
      caneTexture = new THREE.CanvasTexture(canvas);
      caneTexture.wrapS = THREE.RepeatWrapping;
      caneTexture.wrapT = THREE.RepeatWrapping;
      caneTexture.repeat.set(3, 3);
    }

    function createSnow() {
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const velocities = [];

      const canvas = document.createElement('canvas');
      canvas.width = 32; canvas.height = 32;
      const context = canvas.getContext('2d');
      context.fillStyle = 'white';
      context.beginPath();
      context.arc(16, 16, 16, 0, Math.PI * 2);
      context.fill();
      const snowTexture = new THREE.CanvasTexture(canvas);

      for (let i = 0; i < CONFIG.particles.snowCount; i++) {
        vertices.push(
          THREE.MathUtils.randFloatSpread(100),
          THREE.MathUtils.randFloatSpread(60),
          THREE.MathUtils.randFloatSpread(60),
        );
        velocities.push(Math.random() * 0.2 + 0.1, Math.random() * 0.05);
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('userData', new THREE.Float32BufferAttribute(velocities, 2));

      const material = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.4,
        map: snowTexture,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      snowSystem = new THREE.Points(geometry, material);
      scene.add(snowSystem);
    }

    function updateSnow() {
      if (!snowSystem) return;
      snowSystem.visible = STATE.flags.snow;
      if (!STATE.flags.snow) return;

      const positions = snowSystem.geometry.attributes.position.array;
      const userData = snowSystem.geometry.attributes.userData.array;

      for (let i = 0; i < CONFIG.particles.snowCount; i++) {
        const fallSpeed = userData[i * 2];
        positions[i * 3 + 1] -= fallSpeed;

        const swaySpeed = userData[i * 2 + 1];
        positions[i * 3] += Math.sin(clock.elapsedTime * 2 + i) * swaySpeed * 0.1;

        if (positions[i * 3 + 1] < -30) {
          positions[i * 3 + 1] = 30;
          positions[i * 3] = THREE.MathUtils.randFloatSpread(100);
          positions[i * 3 + 2] = THREE.MathUtils.randFloatSpread(60);
        }
      }
      snowSystem.geometry.attributes.position.needsUpdate = true;
    }

    class Particle {
      constructor(mesh, isDust = false) {
        this.mesh = mesh;
        this.isDust = isDust;

        this.posTree = new THREE.Vector3();
        this.posScatter = new THREE.Vector3();
        this.baseScale = mesh.scale.x;

        const speedMult = 2.0;
        this.spinSpeed = new THREE.Vector3(
          (Math.random() - 0.5) * speedMult,
          (Math.random() - 0.5) * speedMult,
          (Math.random() - 0.5) * speedMult
        );
        this.calculatePositions();
      }

      calculatePositions() {
        const h = CONFIG.particles.treeHeight;
        const halfH = h / 2;
        let t = Math.pow(Math.random(), 0.8);
        const y = (t * h) - halfH;

        let rMax = CONFIG.particles.treeRadius * (1.0 - t);
        if (rMax < 0.5) rMax = 0.5;

        const angle = t * 50 * Math.PI + Math.random() * Math.PI;
        const r = rMax * (0.8 + Math.random() * 0.4);
        this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);

        let rScatter = this.isDust ? (12 + Math.random() * 20) : (9 + Math.random() * 14);
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        this.posScatter.set(
          rScatter * Math.sin(phi) * Math.cos(theta),
          rScatter * Math.sin(phi) * Math.sin(theta),
          rScatter * Math.cos(phi)
        );
      }

      update(dt) {
        this.mesh.position.lerp(this.posTree, 2.0 * dt);

        this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, 0, dt);
        this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, 0, dt);
        this.mesh.rotation.y += 0.5 * dt;

        let s = this.baseScale;
        if (this.isDust) {
          s = this.baseScale * (0.8 + 0.4 * Math.sin(clock.elapsedTime * 4 + this.mesh.id));
          s = 0; // dust off on tree for luxury
        }
        this.mesh.scale.lerp(new THREE.Vector3(s, s, s), 4 * dt);
      }
    }

    function createParticles() {
      const sphereGeo = new THREE.SphereGeometry(0.5, 32, 32);
      const boxGeo = new THREE.BoxGeometry(0.55, 0.55, 0.55);
      const curve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0, 0.3, 0),
        new THREE.Vector3(0.1, 0.5, 0), new THREE.Vector3(0.3, 0.4, 0)
      ]);
      const candyGeo = new THREE.TubeGeometry(curve, 16, 0.08, 8, false);

      const goldMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.champagneGold,
        metalness: 1.0, roughness: 0.1,
        envMapIntensity: 2.0,
        emissive: 0x443300,
        emissiveIntensity: 0.35
      });

      const greenMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.deepGreen,
        metalness: 0.2, roughness: 0.85,
        emissive: 0x002200,
        emissiveIntensity: 0.2
      });

      const redMat = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.accentRed,
        metalness: 0.3, roughness: 0.2, clearcoat: 1.0,
        emissive: 0x330000
      });

      const candyMat = new THREE.MeshStandardMaterial({ map: caneTexture, roughness: 0.4 });

      for (let i = 0; i < CONFIG.particles.count; i++) {
        const rand = Math.random();
        let mesh;

        if (rand < 0.40) mesh = new THREE.Mesh(boxGeo, greenMat);
        else if (rand < 0.70) mesh = new THREE.Mesh(boxGeo, goldMat);
        else if (rand < 0.92) mesh = new THREE.Mesh(sphereGeo, goldMat);
        else if (rand < 0.97) mesh = new THREE.Mesh(sphereGeo, redMat);
        else mesh = new THREE.Mesh(candyGeo, candyMat);

        const s = 0.4 + Math.random() * 0.5;
        mesh.scale.set(s, s, s);
        mesh.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6);

        mainGroup.add(mesh);
        particleSystem.push(new Particle(mesh, false));
      }

      // Star
      const starShape = new THREE.Shape();
      const points = 5, outerRadius = 1.5, innerRadius = 0.7;
      for (let i = 0; i < points * 2; i++) {
        const angle = (i * Math.PI) / points + Math.PI / 2;
        const r = (i % 2 === 0) ? outerRadius : innerRadius;
        const x = Math.cos(angle) * r;
        const y = Math.sin(angle) * r;
        if (i === 0) starShape.moveTo(x, y);
        else starShape.lineTo(x, y);
      }
      starShape.closePath();

      const starGeo = new THREE.ExtrudeGeometry(starShape, {
        depth: 0.4, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 2
      });
      starGeo.center();

      const starMat = new THREE.MeshStandardMaterial({
        color: 0xffdd88,
        emissive: 0xffaa00,
        emissiveIntensity: 1.15,
        metalness: 1.0, roughness: 0
      });

      const star = new THREE.Mesh(starGeo, starMat);
      star.position.set(0, CONFIG.particles.treeHeight / 2 + 1.2, 0);
      mainGroup.add(star);
    }

    function createDust() {
      // intentionally minimized (perf)
    }

    // ‚ú® Fairy lights
    function createFairyLights() {
      const count = 520;
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);

      const h = CONFIG.particles.treeHeight * 0.98;
      const halfH = h / 2;

      for (let i = 0; i < count; i++) {
        const t = i / (count - 1);
        const y = t * h - halfH;

        let rMax = CONFIG.particles.treeRadius * (1.0 - t);
        rMax = Math.max(rMax, 0.6);

        const loops = 10.5;
        const angle = t * Math.PI * 2 * loops;

        const r = rMax * 1.02;

        positions[i * 3 + 0] = Math.cos(angle) * r;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = Math.sin(angle) * r;

        const isRed = (i % 7 === 0);
        colors[i * 3 + 0] = 1.0;
        colors[i * 3 + 1] = isRed ? 0.25 : 0.85;
        colors[i * 3 + 2] = isRed ? 0.18 : 0.35;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const mat = new THREE.PointsMaterial({
        size: 0.22,
        vertexColors: true,
        transparent: true,
        opacity: 0.95,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      lightsMesh = new THREE.Points(geo, mat);
      mainGroup.add(lightsMesh);
    }

    function updateFairyLights(dt) {
      if (!lightsMesh) return;
      const t = clock.elapsedTime;
      lightsMesh.material.opacity = 0.72 + 0.22 * Math.sin(t * 2.2);
      lightsMesh.rotation.y += 0.12 * dt;
    }

    // ‚ú® Garland tube spiral
    function createGarland() {
      const h = CONFIG.particles.treeHeight * 0.98;
      const halfH = h / 2;

      const loops = 7.5;
      const segments = 520;
      const points = [];

      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const y = t * h - halfH;

        let rMax = CONFIG.particles.treeRadius * (1.0 - t);
        rMax = Math.max(rMax, 0.65);

        const r = rMax * 1.07;
        const angle = t * Math.PI * 2 * loops + Math.PI / 6;

        points.push(new THREE.Vector3(
          Math.cos(angle) * r,
          y,
          Math.sin(angle) * r
        ));
      }

      const path = new THREE.CatmullRomCurve3(points);
      const tubeGeo = new THREE.TubeGeometry(path, 900, 0.12, 10, false);

      const garlandMat = new THREE.MeshPhysicalMaterial({
        color: 0xffd37a,
        metalness: 1.0,
        roughness: 0.18,
        clearcoat: 1.0,
        clearcoatRoughness: 0.15,
        emissive: 0x553300,
        emissiveIntensity: 0.6
      });

      garlandMesh = new THREE.Mesh(tubeGeo, garlandMat);
      garlandMesh.renderOrder = 2;
      mainGroup.add(garlandMesh);
    }

    function updateGarland(dt) {
      if (!garlandMesh) return;
      const t = clock.elapsedTime;
      garlandMesh.material.emissiveIntensity = 0.55 + 0.25 * Math.sin(t * 2.6);
      garlandMesh.rotation.y += 0.05 * dt;
    }

    // =========================
    // SLOT SYSTEM (3D)
    // =========================
    function computeSlotTargets(){
      slotTargets.length = 0;
      const count = CONFIG.slots.count;
      const h = CONFIG.particles.treeHeight * 0.92;
      const bottomY = -h / 2;
      const stepY = h / count;
      const loops = CONFIG.slots.loops;

      for (let i = 0; i < count; i++) {
        const y = bottomY + stepY * i + stepY / 2;
        const fullH = CONFIG.particles.treeHeight;
        const normalizedH = (y + fullH / 2) / fullH;

        let rMax = CONFIG.particles.treeRadius * (1.0 - normalizedH);
        if (rMax < 1.0) rMax = 1.0;

        const r = rMax + CONFIG.slots.rOffset;
        const angle = normalizedH * Math.PI * 2 * loops + (Math.PI / 4);

        slotTargets.push(new THREE.Vector3(
          Math.cos(angle) * r,
          y,
          Math.sin(angle) * r
        ));
      }
    }

    function makeEmptyTexture(){
      const c = document.createElement('canvas');
      c.width = 256; c.height = 256;
      const g = c.getContext('2d');

      const grd = g.createLinearGradient(0,0,256,256);
      grd.addColorStop(0,'rgba(255,255,255,0.08)');
      grd.addColorStop(1,'rgba(0,0,0,0.22)');
      g.fillStyle = grd;
      g.fillRect(0,0,256,256);

      g.strokeStyle = 'rgba(212,175,55,0.38)';
      g.lineWidth = 6;
      g.strokeRect(14,14,228,228);

      g.fillStyle = 'rgba(252,238,167,0.85)';
      g.font = 'bold 22px Cinzel, serif';
      g.textAlign = 'center';
      g.fillText('TAP SLOT', 128, 124);

      g.fillStyle = 'rgba(212,175,55,0.70)';
      g.font = '14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
      g.fillText('to replace photo', 128, 150);

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    function createSlots3D(){
      computeSlotTargets();

      const frameMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.champagneGold,
        metalness: 1.0,
        roughness: 0.12,
        emissive: 0x332200,
        emissiveIntensity: 0.25
      });

      for (let i = 0; i < CONFIG.slots.count; i++){
        const group = new THREE.Group();
        group.userData.slotIndex = i;

        const frameGeo = new THREE.BoxGeometry(1.55, 1.55, 0.06);
        const frame = new THREE.Mesh(frameGeo, frameMat);
        frame.userData.slotIndex = i;

        const emptyTex = makeEmptyTexture();
        const photoGeo = new THREE.PlaneGeometry(1.42, 1.42);
        const photoMat = new THREE.MeshBasicMaterial({ map: emptyTex, side: THREE.DoubleSide });
        const photo = new THREE.Mesh(photoGeo, photoMat);
        photo.position.z = 0.045;
        photo.userData.slotIndex = i;

        group.add(frame);
        group.add(photo);

        const s = CONFIG.slots.baseScale;
        group.scale.set(s, s, s);

        group.position.copy(slotTargets[i]);
        group.lookAt(0, group.position.y, 0);
        group.rotateY(Math.PI);

        mainGroup.add(group);

        slotMeshes.push({
          group, frame, photo,
          texture: emptyTex,
          assignedId: null,
          isEmpty: true,
          uiThumbEl: null
        });
      }
    }

    function setSlotTexture(slotIndex, texture, assignedId){
      const slot = slotMeshes[slotIndex];
      if (!slot) return;

      texture.colorSpace = THREE.SRGBColorSpace;
      slot.photo.material.map = texture;
      slot.photo.material.needsUpdate = true;

      slot.texture = texture;
      slot.assignedId = assignedId ?? null;
      slot.isEmpty = false;

      updateSlotUIThumb(slotIndex, assignedId);
    }

    function clearSlot(slotIndex){
      const slot = slotMeshes[slotIndex];
      if (!slot) return;

      const empty = makeEmptyTexture();
      slot.photo.material.map = empty;
      slot.photo.material.needsUpdate = true;

      slot.texture = empty;
      slot.assignedId = null;
      slot.isEmpty = true;

      updateSlotUIThumb(slotIndex, null);
    }

    // =========================
    // UI: SLOTS + GALLERY
    // =========================
    function createEmptyThumbDataUrl(){
      const c = document.createElement('canvas');
      c.width = 220; c.height = 220;
      const g = c.getContext('2d');
      g.fillStyle = 'rgba(0,0,0,0.22)';
      g.fillRect(0,0,220,220);
      g.strokeStyle = 'rgba(212,175,55,0.38)';
      g.lineWidth = 6;
      g.strokeRect(14,14,192,192);
      g.fillStyle = 'rgba(252,238,167,0.85)';
      g.font = 'bold 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
      g.textAlign = 'center';
      g.fillText('EMPTY', 110, 118);
      return c.toDataURL('image/png');
    }

    function buildSlotsUI(){
      slotsEl.innerHTML = '';
      for (let i = 0; i < CONFIG.slots.count; i++){
        const div = document.createElement('div');
        div.className = 'slot';
        div.dataset.slot = String(i);

        const num = document.createElement('div');
        num.className = 'num';
        num.textContent = `#${i+1}`;

        const state = document.createElement('div');
        state.className = 'state';
        state.textContent = 'EMPTY';

        const img = document.createElement('img');
        img.alt = `slot-${i+1}`;
        img.src = createEmptyThumbDataUrl();

        div.appendChild(img);
        div.appendChild(num);
        div.appendChild(state);

        div.addEventListener('click', () => toggleSelectSlot(i));

        slotsEl.appendChild(div);

        // store thumb element
        slotMeshes[i].uiThumbEl = div;
      }

      for (let i = 0; i < CONFIG.slots.count; i++){
        updateSlotUIThumb(i, null);
      }
    }

    function updateSlotUIThumb(slotIndex, assignedId){
      const slotDiv = slotMeshes[slotIndex]?.uiThumbEl;
      if (!slotDiv) return;

      const img = slotDiv.querySelector('img');
      const state = slotDiv.querySelector('.state');

      if (!assignedId){
        img.src = createEmptyThumbDataUrl();
        state.textContent = 'EMPTY';
      } else {
        const item = gallery.find(x => x.id === assignedId);
        img.src = item?.thumbUrl || createEmptyThumbDataUrl();
        state.textContent = 'SET';
      }
    }

    function highlightSelectedSlot(){
      slotsEl.querySelectorAll('.slot').forEach(el => {
        const idx = Number(el.dataset.slot);
        el.classList.toggle('selected', idx === STATE.selectedSlot);
      });

      // highlight on 3D too
      for (let i = 0; i < slotMeshes.length; i++){
        const s = slotMeshes[i];
        const isSel = (i === STATE.selectedSlot);
        // subtle glow via scale/emissive feel
        s.group.scale.setScalar(CONFIG.slots.baseScale * (isSel ? 1.08 : 1.0));
      }
    }

    function setSelectedSlot(i, source='ui'){
      STATE.selectedSlot = i;
      slotHint.textContent = `ƒêang ch·ªçn slot #${i+1} ‚Äî tap ·∫£nh trong Gallery ƒë·ªÉ thay`;
      highlightSelectedSlot();
      if (!drawer.classList.contains('open')) openDrawer();
      if (source === '3d') showToast(`ƒê√£ ch·ªçn slot #${i+1} (b·∫•m ·∫£nh ƒë·ªÉ thay)`);
    }

    function toggleSelectSlot(i){
      if (STATE.selectedSlot === i){
        STATE.selectedSlot = -1;
        slotHint.textContent = 'Ch·ªçn 1 slot ƒë·ªÉ thay ·∫£nh';
      } else {
        setSelectedSlot(i, 'ui');
      }
      highlightSelectedSlot();
    }

    function renderGalleryUI(){
      galleryEl.innerHTML = '';
      countBadge.textContent = String(gallery.length);

      gallery.forEach(item => {
        const div = document.createElement('div');
        div.className = 'thumb';
        div.dataset.id = String(item.id);

        const img = document.createElement('img');
        img.src = item.thumbUrl;
        img.alt = `photo-${item.id}`;
        div.appendChild(img);

        div.addEventListener('click', () => {
          // ‚úÖ n·∫øu ch∆∞a ch·ªçn slot -> auto ch·ªçn slot tr·ªëng k·∫ø ti·∫øp
          if (STATE.selectedSlot < 0){
            const nextEmpty = findNextEmptySlot();
            if (nextEmpty < 0){
              setSelectedSlot(0);
            } else {
              setSelectedSlot(nextEmpty);
            }
          }

          setSlotTexture(STATE.selectedSlot, item.texture, item.id);
          showToast(`ƒê√£ thay ·∫£nh cho slot #${STATE.selectedSlot+1}`);

          // ‚úÖ auto nh·∫£y slot ti·∫øp theo ƒë·ªÉ thay nhanh
          const next = findNextSlotAfter(STATE.selectedSlot);
          if (next >= 0){
            STATE.selectedSlot = next;
            slotHint.textContent = `ƒêang ch·ªçn slot #${next+1} ‚Äî tap ·∫£nh ƒë·ªÉ thay`;
            highlightSelectedSlot();
          }
        });

        galleryEl.appendChild(div);
      });
    }

    function findNextEmptySlot(){
      for (let i = 0; i < slotMeshes.length; i++){
        if (slotMeshes[i].isEmpty) return i;
      }
      return -1;
    }

    function findNextSlotAfter(cur){
      // ∆∞u ti√™n slot tr·ªëng tr∆∞·ªõc
      for (let i = cur+1; i < slotMeshes.length; i++){
        if (slotMeshes[i].isEmpty) return i;
      }
      for (let i = 0; i <= cur; i++){
        if (slotMeshes[i].isEmpty) return i;
      }
      // n·∫øu kh√¥ng c√≤n tr·ªëng th√¨ quay v√≤ng
      return (cur + 1) % slotMeshes.length;
    }

    // =========================
    // Upload helpers
    // =========================
    async function fileToDataUrl(file){
      return await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    async function makeThumb(dataUrl, size=240){
      const img = new Image();
      img.src = dataUrl;
      await img.decode();

      const c = document.createElement('canvas');
      c.width = size; c.height = size;
      const g = c.getContext('2d');

      const iw = img.width, ih = img.height;
      const scale = Math.max(size/iw, size/ih);
      const w = iw*scale, h = ih*scale;
      const x = (size - w)/2;
      const y = (size - h)/2;

      g.fillStyle = 'rgba(0,0,0,0.2)';
      g.fillRect(0,0,size,size);
      g.drawImage(img, x, y, w, h);

      const grd = g.createRadialGradient(size/2,size/2, size*0.15, size/2,size/2, size*0.72);
      grd.addColorStop(0,'rgba(255,255,255,0.05)');
      grd.addColorStop(1,'rgba(0,0,0,0.24)');
      g.fillStyle = grd;
      g.fillRect(0,0,size,size);

      return c.toDataURL('image/jpeg', 0.86);
    }

    function dataUrlToTexture(dataUrl){
      const loader = new THREE.TextureLoader();
      return new Promise((resolve, reject) => {
        loader.load(
          dataUrl,
          (tex)=>{ tex.colorSpace = THREE.SRGBColorSpace; resolve(tex); },
          undefined,
          reject
        );
      });
    }

    async function addToGalleryFromDataUrl(dataUrl){
      const thumbUrl = await makeThumb(dataUrl, 240);
      const texture = await dataUrlToTexture(dataUrl);

      const item = {
        id: idCounter++,
        dataUrl,
        thumbUrl,
        texture
      };
      gallery.unshift(item);
      renderGalleryUI();
      autoFillEmptySlots();
    }

    function autoFillEmptySlots(){
      const empties = slotMeshes
        .map((s, idx)=>({s, idx}))
        .filter(x=>x.s.isEmpty);

      if (!empties.length) return;

      for (const e of empties){
        const item = gallery.find(g => !slotMeshes.some(sm => sm.assignedId === g.id)) || gallery[0];
        if (!item) break;
        setSlotTexture(e.idx, item.texture, item.id);
      }
    }

    async function handleUploadFiles(files){
      const arr = Array.from(files || []).filter(f => f.type.startsWith('image/'));
      if (!arr.length) return;

      showToast(`ƒêang n·∫°p ${arr.length} ·∫£nh...`);
      for (const f of arr){
        const dataUrl = await fileToDataUrl(f);
        await addToGalleryFromDataUrl(dataUrl);
      }
      showToast('Xong! B·∫•m v√†o khung tr√™n c√¢y ƒë·ªÉ ch·ªçn slot');
    }

    async function preloadGallery(){
      for (const url of CONFIG.preloadThumbs){
        try{
          const dataUrl = await fetchToDataUrl(url);
          await addToGalleryFromDataUrl(dataUrl);
        }catch(e){}
      }
    }

    async function fetchToDataUrl(url){
      const res = await fetch(url, { mode:'cors' });
      const blob = await res.blob();
      return await new Promise((resolve, reject)=>{
        const reader = new FileReader();
        reader.onload = ()=>resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    // =========================
    // Menu & Drawer
    // =========================
    function openMenu(){ menuPanel.classList.add('open'); menuBackdrop.classList.add('open'); }
    function closeMenu(){ menuPanel.classList.remove('open'); menuBackdrop.classList.remove('open'); }
    function toggleMenu(){ menuPanel.classList.contains('open') ? closeMenu() : openMenu(); }

    function openDrawer(){
      drawer.classList.add('open');
      drawerBackdrop.classList.add('open');
    }
    function closeDrawer(){
      drawer.classList.remove('open');
      drawerBackdrop.classList.remove('open');
      // reset drag transform
      drawer.style.transform = '';
      drawer.style.transition = '';
      STATE.drawerDragDY = 0;
    }
    function toggleDrawer(){
      drawer.classList.contains('open') ? closeDrawer() : openDrawer();
    }

    function toggleUI(){
      STATE.flags.uiHidden = !STATE.flags.uiHidden;
      document.getElementById('ui-layer').classList.toggle('ui-hidden', STATE.flags.uiHidden);
      closeMenu();
    }

    function resetView(){
      STATE.rotation.x = 0;
      STATE.rotation.y = 0;
      closeMenu();
    }

    function shuffleSlots(){
      const ids = slotMeshes.map(s => s.assignedId).filter(Boolean);
      if (!ids.length) { showToast('Kh√¥ng c√≥ ·∫£nh ƒë·ªÉ shuffle'); return; }

      for (let i = ids.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [ids[i], ids[j]] = [ids[j], ids[i]];
      }

      let k = 0;
      for (let i = 0; i < slotMeshes.length; i++){
        if (slotMeshes[i].assignedId){
          const id = ids[k++];
          const item = gallery.find(g => g.id === id);
          if (item) setSlotTexture(i, item.texture, item.id);
        }
      }
      showToast('ƒê√£ shuffle ·∫£nh trong slots');
      closeMenu();
    }

    // Drawer drag-to-close (iOS-ish)
    function setupDrawerDrag(){
      const start = (y) => {
        if (!drawer.classList.contains('open')) return;
        STATE.drawerDragging = true;
        STATE.drawerStartY = y;
        STATE.drawerDragDY = 0;
        drawer.style.transition = 'none';
      };
      const move = (y) => {
        if (!STATE.drawerDragging) return;
        const dy = Math.max(0, y - STATE.drawerStartY);
        STATE.drawerDragDY = dy;
        drawer.style.transform = `translateY(${dy}px)`;
      };
      const end = () => {
        if (!STATE.drawerDragging) return;
        STATE.drawerDragging = false;
        drawer.style.transition = '0.18s ease';
        if (STATE.drawerDragDY > 90) closeDrawer();
        else drawer.style.transform = `translateY(0px)`;
      };

      drawerHead.addEventListener('touchstart', (e)=> start(e.touches[0].clientY), {passive:true});
      drawerHead.addEventListener('touchmove', (e)=> move(e.touches[0].clientY), {passive:true});
      drawerHead.addEventListener('touchend', end, {passive:true});

      drawerHead.addEventListener('pointerdown', (e)=> start(e.clientY));
      window.addEventListener('pointermove', (e)=> move(e.clientY));
      window.addEventListener('pointerup', end);
    }

    // =========================
    // Click on 3D slots
    // =========================
    function onCanvasPointerDown(e){
      // ignore when clicking UI
      if (drawer.classList.contains('open')) return;
      if (menuPanel.classList.contains('open')) return;

      const rect = renderer.domElement.getBoundingClientRect();
      const x = ( (e.clientX - rect.left) / rect.width ) * 2 - 1;
      const y = - ( (e.clientY - rect.top) / rect.height ) * 2 + 1;
      pointer.set(x, y);

      raycaster.setFromCamera(pointer, camera);

      // collect clickable objects (photo + frame)
      const clickables = [];
      for (const s of slotMeshes){
        clickables.push(s.photo);
        clickables.push(s.frame);
      }

      const hits = raycaster.intersectObjects(clickables, true);
      if (hits.length){
        const idx = hits[0].object.userData.slotIndex;
        if (typeof idx === 'number'){
          setSelectedSlot(idx, '3d');
          openDrawer();
        }
      }
    }

    // =========================
    // Events
    // =========================
    function setupEvents(){
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });

      // canvas tap for slot select
      renderer.domElement.addEventListener('pointerdown', onCanvasPointerDown);

      // menu
      menuBtn.addEventListener('click', (e)=>{ e.stopPropagation(); toggleMenu(); });
      menuBackdrop.addEventListener('click', closeMenu);
      window.addEventListener('click', closeMenu);
      menuPanel.addEventListener('click', (e)=>e.stopPropagation());

      // drawer
      drawerBtn.addEventListener('click', (e)=>{ e.stopPropagation(); toggleDrawer(); closeMenu(); });
      btnCloseDrawer.addEventListener('click', closeDrawer);
      drawerBackdrop.addEventListener('click', closeDrawer);
      setupDrawerDrag();

      // menu buttons
      document.getElementById('btn-snow').addEventListener('click', () => {
        STATE.flags.snow = !STATE.flags.snow;
        snowState.textContent = STATE.flags.snow ? 'ON' : 'OFF';
      });
      document.getElementById('btn-reset').addEventListener('click', resetView);
      document.getElementById('btn-ui-toggle').addEventListener('click', toggleUI);
      document.getElementById('btn-shuffle').addEventListener('click', shuffleSlots);

      // upload
      fileInput.addEventListener('change', async (e)=>{
        await handleUploadFiles(e.target.files);
        e.target.value = '';
      });

      // clear slot
      document.getElementById('btn-clear-slot').addEventListener('click', ()=>{
        if (STATE.selectedSlot < 0){
          showToast('Ch·ªçn slot tr∆∞·ªõc ƒë·ªÉ Clear');
          return;
        }
        clearSlot(STATE.selectedSlot);
        showToast(`ƒê√£ clear slot #${STATE.selectedSlot+1}`);
      });

      // keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        const k = e.key.toLowerCase();
        if (k === 'escape'){ closeMenu(); closeDrawer(); }
        if (k === 'h') toggleUI();
        if (k === 'r') resetView();
      });
    }

    // =========================
    // Animate
    // =========================
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      STATE.rotation.y += 0.22 * dt;
      STATE.rotation.x += (0 - STATE.rotation.x) * 2.0 * dt;

      mainGroup.rotation.y = STATE.rotation.y;
      mainGroup.rotation.x = STATE.rotation.x;

      // make slots face out nicely
      for (let i = 0; i < slotMeshes.length; i++){
        const g = slotMeshes[i].group;
        g.rotation.z = 0.02 * Math.sin(clock.elapsedTime * 0.8 + i);
        g.rotation.x = 0.02 * Math.cos(clock.elapsedTime * 0.7 + i);
        g.lookAt(0, g.position.y, 0);
        g.rotateY(Math.PI);
      }

      particleSystem.forEach(p => p.update(dt));
      updateFairyLights(dt);
      updateGarland(dt);
      updateSnow();

      composer.render();
    }

    // Boot
    init();
  </script>
</body>
</html>
